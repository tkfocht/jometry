<html>
    <head>
        <title>J!ometry: Daily Jeopardy Visualizations</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto">
        <link rel="stylesheet" href="css/site.css"></link>
        <link rel="stylesheet" href="css/season.css"></link>
        <script src="/js/d3/d3.v7.min.js"></script>
        <script src="/js/util/util.v1.js"></script>
        <script src="/js/graphs/full_game_scatter.v1.js"></script>
        <script src="/js/graphs/by_round_scatter.v1.js"></script>
    </head>
    <body>
        <h1><a href="index.html">J!ometry</a></h1>
        <div>
            <a href="/index.html">Home</a>&nbsp;<a href="/glossary.html">Glossary</a>
        </div>
        <div class="section">
            <h1><span id="season-id"></span> Season Summary</h1>
            <div class="graph-description">
                "Average" is the average of all contestant performances, not just those shown individually. Each game performace
                is a separate data point, so champions are included separately in the average for each of their games.
            </div>
            <div id="season-contestant-summary">
                <table>
                    <thead>
                        <tr>
                            <th colspan="2" class="empty"></th>
                            <th colspan="7">Jeopardy! Round Avg</th>
                            <th colspan="7">Double Jeopardy! Round Avg</th>
                            <th colspan="1" class="empty"></th>
                        </tr>
                        <tr>
                            <th>Contestant</th>
                            <th>Wins</th>
                            <th>ATT</th>
                            <th>COB</th>
                            <th>BCOE</th>
                            <th>CCON</th>
                            <th>SOB</th>
                            <th>DDF</th>
                            <th>DDOE</th>
                            <th>ATT</th>
                            <th>COB</th>
                            <th>BCOE</th>
                            <th>CCON</th>
                            <th>SOB</th>
                            <th>DDF</th>
                            <th>DDOE</th>
                            <th>Total Buzz%</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="graph-description">
                ATT = Attempts, COB = Correct on Buzz, BCOE = Buzz (Correct) Over Expectation, CCON = Contestant-specific Contention, SOB = Score on Buzz, DDF = Daily Doubles Found, DDOE = Daily Doubles over Expectation
            </div>
        </div>
        <div class="section">
            <h1>Average Attempt Distribution</h1>
            <div class="graph-description">
                Average buzz attempts, by contestant and round. Correct responses are at the bottom, incorrect responses are lighter and
                in the middle, and attempts where the contestant was locked out are lightest and at the top. "Average" is the average of
                all contestant performances, not just those shown individually. Each game performance is a separate
                data point, so champions are included separately in the average for each of their games.
            </div>
            <div id="bar-attempts"></div>
        </div>
        <div class="section">
            <h1>BCOE vs CCON</h1>
            <div class="graph-description">
                BCOE is an estimate of additional buzzes a contestant creates through speed (or opponents' lack of speed). A
                higher BCOE represents winning a higher number of buzzer races. CCON is an estimate of how often a
                contestant is blocking an opponent's attempt to answer by ringing in first and giving a correct response.
                Lower CCON represents a contestant that is the only player ringing in more often.
            </div>
            <div id="scatter-bcoe-ccon-j"></div>
            <div id="scatter-bcoe-ccon-dj"></div>
            <div id="scatter-bcoe-ccon-game"></div>
            <div id="scatter-bcoe-ccon-combined"></div>
        </div>
        <div class="section">
            <h1>ATT vs BUZZ%</h1>
            <div class="graph-description">
                Number of attempts to buzz and percent of successful buzzes, over the whole game.
            </div>
            <div id="scatter-att-buzz-pct"></div>
        </div>
        <div class="section">
            <h1>ATT vs BUZZ% by Round</h1>
            <div class="graph-description">
                Number of attempts to buzz and percent of successful buzzes, over the whole game. Jeopardy! round
                is circles, connected to Double Jeopardy! round as squares.
            </div>
            <div id="scatter-att-buzz-pct-by-round"></div>
        </div>
        <div class="section">
            <h1>ATT vs $/ATT</h1>
            <div class="graph-description">
                Number of attempts to buzz and money earned on buzzes per attempt, over the whole game.
            </div>
            <div id="scatter-att-score-att"></div>
        </div>
        <div class="section">
            <h1>ATT vs $/ATT by Round</h1>
            <div class="graph-description">
                Number of attempts to buzz and money earned on buzzes per attempt, over the whole game. Jeopardy! round
                is circles, connected to Double Jeopardy! round as squares.
            </div>
            <div id="scatter-att-score-att-by-round"></div>
        </div>
        <div class="section">
            <h1>ATT vs $/BUZ</h1>
            <div class="graph-description">
                Number of attempts to buzz and money earned per buzz, over the whole game.
            </div>
            <div id="scatter-att-score-buzz"></div>
        </div>
        <div class="section">
            <h1>ATT vs $/BUZ by Round</h1>
            <div class="graph-description">
                Number of attempts to buzz and money earned per buzz, over the whole game. Jeopardy! round
                is circles, connected to Double Jeopardy! round as squares.
            </div>
            <div id="scatter-att-score-buzz-by-round"></div>
        </div>
        <div id="footer">
            <p>This site is not affiliated with Jeopardy!. Data is taken from their published <a href="https://www.jeopardy.com/jbuzz/news-events/jeopardy-daily-box-scores">box scores.</a></p>
        </div>
        <script type="text/javascript">
            var seasonId = new URLSearchParams(window.location.search).get('season');
            var seasonAverageLabel = seasonId + " Average";
            d3.select("#season-id")
                .data([seasonId])
                .text(d => d);
            d3.csv(csvUrlForSeason(seasonId)).then(function(data) {
                //Baseline for graphs
                var margin = {top: 20, right: 20, bottom: 50, left: 70},
                    width = 960 - margin.left - margin.right,
                    height = 500 - margin.top - margin.bottom;

                //Data transformations
                data.forEach(function(d) {
                    d['Date'] = csvDateParse(d['Date']);
                    d['J! Buzz %'] = 100.0 * d['J! Buzzes'] / d['J! Attempts'];
                    d['DJ! Buzz %'] = 100.0 * d['DJ! Buzzes'] / d['DJ! Attempts'];
                    d['Total Buzz %'] = 100.0 * d['Total Buzz'] / d['Total Attempt'];
                });
                var highlightContestantCounts = d3.rollup(data, v => d3.sum(d3.map(v, cd => (+cd['Wins']))), d => d['Contestant']);
                var gameThreshold = 1;
                highlightContestants = d3.filter(highlightContestantCounts.keys(), k => highlightContestantCounts.get(k) >= gameThreshold);
                while (highlightContestants.length > 12) {
                    gameThreshold += 1;
                    highlightContestants = d3.filter(highlightContestantCounts.keys(), k => highlightContestantCounts.get(k) >= gameThreshold);
                }
                highlightContestants.sort(function(a,b) { return highlightContestantCounts.get(b) - highlightContestantCounts.get(a); });
                data.forEach(function(d) {
                    d['highlightContestant'] = highlightContestants.includes(d['Contestant']);
                });

                //Graphics functions
                var color = d3.scaleOrdinal()
                    .domain(highlightContestants)
                    .range(d3.schemeCategory10.concat(d3.schemeSet3.slice(2)));
                var colorFunction = function(d) {
                    if (d['highlightContestant']) {
                        return color(d['Contestant']);
                    } else {
                        return "black";
                    }
                };
                var opacityFunction = function(d) {
                    if (d['highlightContestant']) {
                        return 1;
                    } else {
                        return 0.1;
                    }
                };
                var labelFunction = function(d) {
                    return "";
                };

                var summarizeContestantData = function(contestant, contestantData) {
                    return {
                        'Contestant': contestant,
                        'Wins': d3.sum(d3.map(contestantData, cd => (+cd['Wins']))),
                        'Avg J! Attempts': d3.mean(d3.map(contestantData, cd => (+cd['J! Attempts']))),
                        'Avg J! Buzzes': d3.mean(d3.map(contestantData, cd => (+cd['J! Buzzes']))),
                        'Avg J! Correct on Buzz': d3.mean(d3.map(contestantData, cd => (+cd['J! Correct on Buzz']))),
                        'Avg J! Expected Buzz Difference': d3.mean(d3.map(contestantData, cd => (+cd['J! Expected Buzz Difference']))),
                        'Avg J! Contestant Contention': d3.mean(d3.map(contestantData, cd => (+cd['J! Contestant Contention']))),
                        'Avg J! Score on Buzz': d3.mean(d3.map(contestantData, cd => (+cd['J! Score on Buzz']))),
                        'Avg J! DDs found': d3.mean(d3.map(contestantData, cd => (+cd['J! DDs found']))),
                        'Avg J! DDs over Expectation': d3.mean(d3.map(contestantData, cd => (+cd['J! DD Exp Diff']))),
                        'Avg DJ! Attempts': d3.mean(d3.map(contestantData, cd => (+cd['DJ! Attempts']))),
                        'Avg DJ! Buzzes': d3.mean(d3.map(contestantData, cd => (+cd['DJ! Buzzes']))),
                        'Avg DJ! Correct on Buzz': d3.mean(d3.map(contestantData, cd => (+cd['DJ! Correct on Buzz']))),
                        'Avg DJ! Expected Buzz Difference': d3.mean(d3.map(contestantData, cd => (+cd['DJ! Expected Buzz Difference']))),
                        'Avg DJ! Contestant Contention': d3.mean(d3.map(contestantData, cd => (+cd['DJ! Contestant Contention']))),
                        'Avg DJ! Score on Buzz': d3.mean(d3.map(contestantData, cd => (+cd['DJ! Score on Buzz']))),
                        'Avg DJ! DDs found': d3.mean(d3.map(contestantData, cd => (+cd['DJ! DDs found']))),
                        'Avg DJ! DDs over Expectation': d3.mean(d3.map(contestantData, cd => (+cd['DJ! DD Exp Diff']))),
                        'Total Buzz %': 100.0 * d3.sum(d3.map(contestantData, cd => (+cd['Total Buzz']))) / d3.sum(d3.map(contestantData, cd => (+cd['Total Attempt'])))
                    };
                }


                //Summary table
                var summaryData = Array.from(
                    d3.group(d3.filter(data, d => d['highlightContestant']), d => d['Contestant']),
                    ([contestant, contestantData]) => summarizeContestantData(contestant, contestantData));
                summaryData.sort(function(a,b) { return highlightContestantCounts.get(b['Contestant']) - highlightContestantCounts.get(a['Contestant']); });

                var averageSummary = summarizeContestantData(seasonAverageLabel, data);
                averageSummary['Wins'] = "";
                var summaryDataWithAverage = summaryData.concat(averageSummary);
                var summaryColorFunction = function(d) {
                    if (d['Contestant'] === seasonAverageLabel) {
                        return "black";
                    } else {
                        return color(d['Contestant']);
                    }
                }

                var summaryTr = d3.select("#season-contestant-summary table tbody")
                    .selectAll("tr")
                    .data(summaryDataWithAverage)
                    .enter()
                    .append("tr");
                summaryTr.selectAll("td")
                    .data(function(d,i) {
                        return [
                            d['Contestant'],
                            d['Wins'],
                            d['Avg J! Attempts'].toFixed(1),
                            d['Avg J! Correct on Buzz'].toFixed(1),
                            (d['Avg J! Expected Buzz Difference'] >= 0 ? "+" : "") + d['Avg J! Expected Buzz Difference'].toFixed(1),
                            (100 * d['Avg J! Contestant Contention']).toFixed(0) + "%",
                            d['Avg J! Score on Buzz'].toFixed(0),
                            d['Avg J! DDs found'].toFixed(1),
                            (d['Avg J! DDs over Expectation'] >= 0 ? "+" : "") + d['Avg J! DDs over Expectation'].toFixed(1),
                            d['Avg DJ! Attempts'].toFixed(1),
                            d['Avg DJ! Correct on Buzz'].toFixed(1),
                            (d['Avg DJ! Expected Buzz Difference'] >= 0 ? "+" : "") + d['Avg DJ! Expected Buzz Difference'].toFixed(1),
                            (100 * d['Avg DJ! Contestant Contention']).toFixed(0) + "%",
                            d['Avg DJ! Score on Buzz'].toFixed(0),
                            d['Avg DJ! DDs found'].toFixed(1),
                            (d['Avg DJ! DDs over Expectation'] >= 0 ? "+" : "") + d['Avg DJ! DDs over Expectation'].toFixed(1),
                            d['Total Buzz %'].toFixed(1)
                        ];
                    })
                    .enter()
                    .append("td")
                    .html(function(d,i) {
                        if (i>0) return d;
                        if (d === seasonAverageLabel) return '<span style="color:black">&#9632;</span>&nbsp;' + d;
                        return '<span style="color: ' + color(d) + '">&#9632;</span>&nbsp;<a href="contestant.html?season=' + seasonId + '&contestant=' + d + '">' + d + "</a>";
                    });


                var addLegend = function(
                    svg,
                    xTranslation = 175,
                    yTranslation = 0
                ) {
                    var legend = svg.append("g")
                        .attr("transform", "translate(" + (xTranslation - width) + "," + yTranslation + ")")
                        .attr("font-size", 13)
                        .attr("text-anchor", "start")
                        .selectAll("g")
                        .data(highlightContestants)
                        .enter().append("g")
                        .attr("transform", function(d, i) { return "translate(0," + i * 16 + ")"; });
                    legend.append("circle")
                        .attr("cx", width - 142)
                        .attr("cy", 4)
                        .attr("r", 5)
                        .attr("fill", color)
                        .attr("stroke", "black");
                    legend.append("text")
                        .attr("x", width - 133)
                        .attr("y", 5.5)
                        .attr("dy", "0.22em")
                        .text(d => (d));
                }


                //BCOE vs CCON
                data.forEach(function(d) {
                    d['J! Contestant Contention %'] = 100.0 * d['J! Contestant Contention'];
                    d['DJ! Contestant Contention %'] = 100.0 * d['DJ! Contestant Contention'];
                    d['Total Contestant Contention %'] = 100.0 * d['Total Contestant Contention'];
                });
                var bcoeCconJScatterSvg = fullGameScatter(
                    '#scatter-bcoe-ccon-j',
                    data,
                    'J! Exp Uncontested', [0, 20], 'J! Exp Uncon',
                    'J! Expected Buzz Difference', [-10,10], 'J! BCOE',
                    colorFunction, opacityFunction, labelFunction,
                    width, height, margin
                );
                addLegend(bcoeCconJScatterSvg, width, 0);

                var bcoeCconDJScatterSvg = fullGameScatter(
                    '#scatter-bcoe-ccon-dj',
                    data,
                    'DJ! Exp Uncontested', [0, 20], 'DJ! Exp Uncon',
                    'DJ! Expected Buzz Difference', [-10,10], 'DJ! BCOE',
                    colorFunction, opacityFunction, labelFunction,
                    width, height, margin
                );
                addLegend(bcoeCconDJScatterSvg, width, 0);

                var bcoeCconGameScatterSvg = fullGameScatter(
                    '#scatter-bcoe-ccon-game',
                    data,
                    'Total Exp Uncontested', [0, 20], 'Game Exp Uncon',
                    'Total Expected Buzz Difference', [-12,20], 'Game BCOE',
                    colorFunction, opacityFunction, labelFunction,
                    width, height, margin
                );
                addLegend(bcoeCconGameScatterSvg, width, 0);

                var bcoeCconByRoundScatterSvg = byRoundScatter(
                    '#scatter-bcoe-ccon-combined',
                    data,
                    ['J! Exp Uncontested','DJ! Exp Uncontested'], [0, 20], 'Exp Uncon',
                    ['J! Expected Buzz Difference','DJ! Expected Buzz Difference'], [-10,15], 'BCOE',
                    colorFunction, opacityFunction, labelFunction,
                    width, height, margin
                );
                addLegend(bcoeCconByRoundScatterSvg, width, 0);

                //ATT vs $/ATT
                var attAttSvg = fullGameScatter(
                    '#scatter-att-score-att',
                    data,
                    'Total Attempt', [0, 60], 'ATT',
                    'Total Score/Attempt', [-200,800], '$/ATT',
                    colorFunction, opacityFunction, labelFunction,
                    width, height, margin
                );
                addLegend(attAttSvg);


                //ATT vs $/ATT by Round
                var attAttByRoundSvg = byRoundScatter(
                    '#scatter-att-score-att-by-round',
                    data,
                    ['J! Attempts','DJ! Attempts'], [0, 30], 'ATT',
                    ['J! Score/Attempt','DJ! Score/Attempt'], [-400,1200], '$/ATT',
                    colorFunction, opacityFunction, labelFunction,
                    width, height, margin
                );
                addLegend(attAttByRoundSvg);

                //ATT vs $/BUZ
                var attBuzSvg = fullGameScatter(
                    '#scatter-att-score-buzz',
                    data,
                    'Total Attempt', [0, 60], 'ATT',
                    'Total Score/Buzz', [-300,1200], '$/BUZ',
                    colorFunction, opacityFunction, labelFunction,
                    width, height, margin
                );
                addLegend(attBuzSvg);

                //ATT vs $/BUZ by Round
                var attBuzByRoundSvg = byRoundScatter(
                    '#scatter-att-score-buzz-by-round',
                    data,
                    ['J! Attempts','DJ! Attempts'], [0, 30], 'ATT',
                    ['J! Score/Buzz','DJ! Score/Buzz'], [-750,1500], '$/BUZ',
                    colorFunction, opacityFunction, labelFunction,
                    width, height, margin
                );
                addLegend(attBuzByRoundSvg);

                //ATT vs Buzz%
                var attBuzPctSvg = fullGameScatter(
                    '#scatter-att-buzz-pct',
                    data,
                    'Total Attempt', [0, 60], 'ATT',
                    'Total Buzz %', [0, 100], 'BUZZ %',
                    colorFunction, opacityFunction, labelFunction,
                    width, height, margin
                );
                addLegend(attBuzPctSvg);

                //ATT vs Buzz% by round
                var attBuzPctByRoundSvg = byRoundScatter(
                    '#scatter-att-buzz-pct-by-round',
                    data,
                    ['J! Attempts','DJ! Attempts'], [0, 30], 'ATT',
                    ['J! Buzz %','DJ! Buzz %'], [0, 100], 'BUZZ %',
                    colorFunction, opacityFunction, labelFunction,
                    width, height, margin
                );
                addLegend(attBuzPctByRoundSvg);


                //Attempt Distribution
                svg = d3.select("#bar-attempts").append("svg")
                                .attr("width", width + margin.left + margin.right)
                                .attr("height", height + margin.top + margin.bottom)
                            .append("g")
                            .attr("transform",
                                "translate(" + margin.left + "," + margin.top + ")");
                var x = d3.scaleBand()
                    .domain(['J!', 'DJ!'])
                    .range([0, width])
                    .padding([0.2]);
                var y = d3.scaleLinear().range([height, 0]);
                y.domain([0, 30]);
                svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x).tickSize(0));
                svg.append("g")
                    .call(d3.axisLeft(y));
                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 0 - margin.left)
                    .attr("x",0 - (height / 2))
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .text("Correct");  

                var xSubgroup = d3.scaleBand()
                    .domain(highlightContestants.concat([seasonAverageLabel]))
                    .range([0, x.bandwidth()])
                    .padding([0.05]);

                var jG = svg.append('g')
                    .attr("transform", function(d) { return "translate(" + x('J!') + ",0)"; });
                var jGCorrectG = jG.append('g');
                var jGIncorrectG = jG.append('g');
                var jGLockedG = jG.append('g');
                jGCorrectG.selectAll('rect')
                    .data(summaryDataWithAverage)
                    .enter()
                    .append('rect')
                    .attr('x', function(d) { return xSubgroup(d['Contestant']); })
                    .attr('y', function(d) { return y(d['Avg J! Correct on Buzz']); })
                    .attr("width", xSubgroup.bandwidth())
                    .attr("height", function(d) { return height - y(d['Avg J! Correct on Buzz']); })
                    .attr("fill", summaryColorFunction);
                jGIncorrectG.selectAll('rect')
                    .data(summaryDataWithAverage)
                    .enter()
                    .append('rect')
                    .attr('x', function(d) { return xSubgroup(d['Contestant']); })
                    .attr('y', function(d) { return y(d['Avg J! Buzzes']); })
                    .attr("width", xSubgroup.bandwidth())
                    .attr("height", function(d) { return height - y(d['Avg J! Buzzes'] - d['Avg J! Correct on Buzz']); })
                    .attr("fill", summaryColorFunction)
                    .attr("opacity", 0.7);
                jGLockedG.selectAll('rect')
                    .data(summaryDataWithAverage)
                    .enter()
                    .append('rect')
                    .attr('x', function(d) { return xSubgroup(d['Contestant']); })
                    .attr('y', function(d) { return y(d['Avg J! Attempts']); })
                    .attr("width", xSubgroup.bandwidth())
                    .attr("height", function(d) { return height - y(d['Avg J! Attempts'] - d['Avg J! Buzzes']); })
                    .attr("fill", summaryColorFunction)
                    .attr("opacity", 0.3);
                jG.selectAll('text')
                    .data(summaryDataWithAverage)
                    .enter()
                    .append('text')
                    .attr('x', function(d) { return xSubgroup(d['Contestant']) + 5; })
                    .attr('y', function(d) { return y(d['Avg J! Attempts']); })
                    .attr('transform', function(d) { return 'rotate(-45, ' + (xSubgroup(d['Contestant']) + 5) + ',' + y(d['Avg J! Attempts']) + ')'; })
                    .text(d => d['Contestant']);

                var djG = svg.append('g')
                    .attr("transform", function(d) { return "translate(" + x('DJ!') + ",0)"; });
                var djGCorrectG = djG.append('g');
                var djGIncorrectG = djG.append('g');
                var djGLockedG = djG.append('g');
                djGCorrectG.selectAll('rect')
                    .data(summaryDataWithAverage)
                    .enter()
                    .append('rect')
                    .attr('x', function(d) { return xSubgroup(d['Contestant']); })
                    .attr('y', function(d) { return y(d['Avg DJ! Correct on Buzz']); })
                    .attr("width", xSubgroup.bandwidth())
                    .attr("height", function(d) { return height - y(d['Avg DJ! Correct on Buzz']); })
                    .attr("fill", summaryColorFunction);
                djGIncorrectG.selectAll('rect')
                    .data(summaryDataWithAverage)
                    .enter()
                    .append('rect')
                    .attr('x', function(d) { return xSubgroup(d['Contestant']); })
                    .attr('y', function(d) { return y(d['Avg DJ! Buzzes']); })
                    .attr("width", xSubgroup.bandwidth())
                    .attr("height", function(d) { return height - y(d['Avg DJ! Buzzes'] - d['Avg DJ! Correct on Buzz']); })
                    .attr("fill", summaryColorFunction)
                    .attr("opacity", 0.7);
                djGLockedG.selectAll('rect')
                    .data(summaryDataWithAverage)
                    .enter()
                    .append('rect')
                    .attr('x', function(d) { return xSubgroup(d['Contestant']); })
                    .attr('y', function(d) { return y(d['Avg DJ! Attempts']); })
                    .attr("width", xSubgroup.bandwidth())
                    .attr("height", function(d) { return height - y(d['Avg DJ! Attempts'] - d['Avg DJ! Buzzes']); })
                    .attr("fill", summaryColorFunction)
                    .attr("opacity", 0.3);
                djG.selectAll('text')
                    .data(summaryDataWithAverage)
                    .enter()
                    .append('text')
                    .attr('x', function(d) { return xSubgroup(d['Contestant']) + 5; })
                    .attr('y', function(d) { return y(d['Avg DJ! Attempts']); })
                    .attr('transform', function(d) { return 'rotate(-45, ' + (xSubgroup(d['Contestant']) + 5) + ',' + y(d['Avg DJ! Attempts']) + ')'; })
                    .text(d => d['Contestant']);


            });
        </script>
    </body>
</html>